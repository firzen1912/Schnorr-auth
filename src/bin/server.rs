use std::io::{Read, Write};
use std::net::TcpListener;

// Import necessary crates for Curve25519 cryptography, key derivation, transcript, RNG, and zeroization.
use curve25519_dalek::constants::RISTRETTO_BASEPOINT_POINT;
use curve25519_dalek::ristretto::{CompressedRistretto, RistrettoPoint};
use curve25519_dalek::scalar::Scalar;
use hkdf::Hkdf;
use merlin::Transcript;
use rand::{rngs::OsRng, RngCore};
use sha2::Sha256;
use zeroize::Zeroize;

/// Generate a random scalar appropriate for the Ristretto group used by Curve25519.
fn random_scalar() -> Scalar {
    let mut bytes = [0u8; 64];
    OsRng.fill_bytes(&mut bytes);
    // Use the wide reduction method to create a valid Scalar from 64 random bytes.
    Scalar::from_bytes_mod_order_wide(&bytes)
}

/// Creates a non-interactive Schnorr proof of knowledge for a given secret `x`
/// using the Fiat-Shamir heuristic and a transcript.
fn schnorr_prove(x: &Scalar, label: &'static [u8]) -> (RistrettoPoint, RistrettoPoint, Scalar) {
    let pubkey = RISTRETTO_BASEPOINT_POINT * x;

    // 1. Prover generates a random nonce `r` and computes a commitment `a`.
    let r = random_scalar();
    let a = RISTRETTO_BASEPOINT_POINT * r;

    // 2. Transcript is initialized to bind the proof to a specific context/label.
    let mut t = Transcript::new(label);
    t.append_message(b"pubkey", pubkey.compress().as_bytes());
    t.append_message(b"a", a.compress().as_bytes());

    // 3. The 'challenge' `c` is generated deterministically by hashing the transcript content (Fiat-Shamir).
    let mut buf = [0u8; 64];
    t.challenge_bytes(b"c", &mut buf);
    let c = Scalar::from_bytes_mod_order_wide(&buf);

    // 4. The response `s` is calculated: s = r + c * x (mod L)
    let s = r + c * x;
    
    // Returns the public key, the commitment 'a', and the response 's'
    (pubkey, a, s)
}

/// Verifies a non-interactive Schnorr proof generated by `schnorr_prove`.
fn schnorr_verify(pubkey: &RistrettoPoint, a: &RistrettoPoint, s: &Scalar, label: &'static [u8]) -> bool {
    // Reconstruct the same transcript and challenge that the prover used.
    let mut t = Transcript::new(label);
    t.append_message(b"pubkey", pubkey.compress().as_bytes());
    t.append_message(b"a", a.compress().as_bytes());

    let mut buf = [0u8; 64];
    t.challenge_bytes(b"c", &mut buf);
    let c = Scalar::from_bytes_mod_order_wide(&buf);

    // Verify the equation: G*s == a + pubkey*c
    // If this holds, the prover must have known the secret key `x` such that pubkey = G*x.
    let lhs = RISTRETTO_BASEPOINT_POINT * s;
    let rhs = a + pubkey * c;
    lhs == rhs
}

/// Derives a shared, secret session key using Elliptic Curve Diffie-Hellman (ECDH)
/// and HKDF for key strengthening.
fn derive_session_key(secret: &Scalar, peer_pub: &RistrettoPoint, nonce1: &[u8; 32], nonce2: &[u8; 32]) -> [u8; 32] {
    // Perform ECDH to get the shared secret point (P * s)
    let shared = peer_pub * secret;
    let shared_bytes = shared.compress().to_bytes();

    // Use nonces as 'info' context for HKDF
    let mut info = Vec::new();
    info.extend_from_slice(nonce1);
    info.extend_from_slice(nonce2);

    // HKDF (HMAC-based Key Derivation Function) with SHA256
    let hk = Hkdf::<Sha256>::new(Some(&info), &shared_bytes);
    let mut okm = [0u8; 32]; // Output Key Material (32 bytes for the session key)
    hk.expand(b"session key", &mut okm).unwrap();
    okm
}

// --- Network Helper Functions for TCP Communication ---

fn recv_exact(stream: &mut impl Read, buf: &mut [u8]) -> std::io::Result<()> {
    stream.read_exact(buf)
}

fn send_all(stream: &mut impl Write, buf: &[u8]) -> std::io::Result<()> {
    stream.write_all(buf)
}

fn recv_point(stream: &mut impl Read) -> std::io::Result<RistrettoPoint> {
    let mut b = [0u8; 32];
    recv_exact(stream, &mut b)?;
    let comp = CompressedRistretto(b);
    // Decompress the point bytes back into a RistrettoPoint object
    comp.decompress().ok_or_else(|| std::io::Error::new(std::io::ErrorKind::InvalidData, "invalid point"))
}

fn recv_scalar(stream: &mut impl std::io::Read) -> std::io::Result<Scalar> {
    let mut b = [0u8; 32];
    stream.read_exact(&mut b)?;

    // Safely convert bytes back into a Scalar value
    let ct_opt = Scalar::from_canonical_bytes(b);
    if ct_opt.is_some().unwrap_u8() == 1 {
        Ok(ct_opt.unwrap())
    } else {
        Err(std::io::Error::new(std::io::ErrorKind::InvalidData, "invalid scalar"))
    }
}

// --- Main execution flow for the Server ---

fn main() -> std::io::Result<()> {
    println!("Server: listening on 0.0.0.0:4000");
    // Bind to the TCP port 4000 and start listening for connections.
    let listener = TcpListener::bind("0.0.0.0:4000")?;

    // Iterate over incoming connections.
    for stream in listener.incoming() {
        match stream {
            Ok(mut s) => {
                println!("Client connected: {}", s.peer_addr()?);

                // === Step 1: Generate Server Key Material (Static and Ephemeral secrets zeroized later) ===
                let mut server_static_secret = random_scalar();
                let server_static_pub = RISTRETTO_BASEPOINT_POINT * server_static_secret;

                // === Step 2: Receive Client Credentials ===
                // The server reads the client's public key, proof components (a, s), nonce, and ephemeral public key.
                let client_pub = recv_point(&mut s)?;
                let client_a = recv_point(&mut s)?;
                let client_s = recv_scalar(&mut s)?;
                let mut client_nonce = [0u8; 32];
                recv_exact(&mut s, &mut client_nonce)?;
                let client_eph_pub = recv_point(&mut s)?;
                println!("Server: Received client credentials.");


                // === Step 3: Verify the Client's Schnorr Proof ===
                // The server verifies that the client legitimately owns its static secret key.
                let ok = schnorr_verify(&client_pub, &client_a, &client_s, b"client_schnorr");
                println!("Client proof ok: {}", ok);
                if !ok {
                    eprintln!("Client proof failed, closing connection.");
                    server_static_secret.zeroize();
                    // Shutdown the connection explicitly
                    let _ = s.shutdown(std::net::Shutdown::Both);
                    continue; // Skip to the next incoming connection
                }

                // === Step 4: Generate Server's Schnorr Proof and Ephemeral Keys ===
                let (server_pub_from_prove, server_a, server_s) = schnorr_prove(&server_static_secret, b"server_schnorr");
                assert_eq!(server_pub_from_prove.compress().to_bytes(), server_static_pub.compress().to_bytes());

                let mut server_nonce = [0u8; 32];
                OsRng.fill_bytes(&mut server_nonce);
                let mut server_eph_secret = random_scalar();
                let server_eph_pub = RISTRETTO_BASEPOINT_POINT * server_eph_secret;

                // === Step 5: Send Server Credentials to Client ===
                // The server sends its public key, the proof components (a, s), nonce, and ephemeral public key.
                send_all(&mut s, &server_static_pub.compress().to_bytes())?;
                send_all(&mut s, &server_a.compress().to_bytes())?;
                send_all(&mut s, &server_s.to_bytes())?;
                send_all(&mut s, &server_nonce)?;
                send_all(&mut s, &server_eph_pub.compress().to_bytes())?;
                s.flush()?;
                println!("Server: Sent server credentials.");

                // === Step 6: Derive the Shared Session Key ===
                // This uses the server's ephemeral secret and the client's ephemeral public key (ECDH)
                // combined with both nonces for context/freshness via HKDF.
                let server_key = derive_session_key(&server_eph_secret, &client_eph_pub, &client_nonce, &server_nonce);
                println!("Server derived session key: {}", hex::encode(server_key));

                // === Step 7: Secure Cleanup ===
                // Zeroize sensitive secret keys from memory to prevent side-channel attacks.
                server_static_secret.zeroize();
                server_eph_secret.zeroize();

                println!("Server finished connection; closing.");
            }
            Err(e) => eprintln!("incoming connection failed: {}", e),
        }
    }

    Ok(())
}
